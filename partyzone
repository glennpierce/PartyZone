#!/usr/bin/env python

import sys
import gi
gi.require_version('Gst', '1.0')
gi.require_version('GstNet', '1.0')
import time
import signal
import select
import Pyro4
import argparse
import os
import os.path
import socket

from gi.repository import GObject, Gst, GstNet
from socket import gethostname

@Pyro4.expose
class Player(object):

    def __init__(self, host, clock_port, master=None):
        self._name = gethostname()
        self._host = host
        self.clock_port = int(clock_port)
        self.master = master
        self.is_master = False if master else True
        self._track_uri = None
        self.playbin = Gst.ElementFactory.make('playbin', 'playbin')

        if self.is_master:
            print("master player started on host: %s" % (self.host,))
        else:
            print("slave player started on host: %s" % (self.host,))

        if self.is_master:
            self.system_clock = Gst.SystemClock.obtain()
            time.sleep(2.0) # Wait for the clock to stabilise
            self.clock_provider = GstNet.NetTimeProvider.new(self.system_clock, self.host, self.clock_port)
            if not self.clock_provider:
                print("No clock_provider set ?")
        else:
            # Check that master is playing or not
            if self.master.state() == Gst.State.PLAYING:
                print "restart playing"

        self.base_time = Gst.CLOCK_TIME_NONE
        self.stop()

    @property
    def name(self):
        return self._name

    @property
    def host(self):
        return self._host
 
    @property
    def track(self):
        if not self._track_uri:
            raise Exception("No track set")
        return self._track_uri

    @track.setter
    def track(self, value):
        print("seeting track to %s" % (value,))
        self._track_uri = value

    def on_message(self, bus, message):
        t = message.type
        if t == Gst.MessageType.EOS:
            #self.player.set_state(Gst.State.NULL)
            pass
        elif t == Gst.MessageType.ERROR:
            #self.player.set_state(Gst.State.NULL)
            err, debug = message.parse_error()
            print("Error: %s" % err, debug)

    def get_basetime(self):
        return self.base_time

    def state(self):
        state = int(self.playbin.get_state(Gst.CLOCK_TIME_NONE)[1])
        print(state)
        return state

    def stop(self):
        self.playbin.set_state(Gst.State.NULL)

    def play(self):

        if self.is_master:
            #print("connecting to net clock %s:%s" % (self.host, self.clock_port))
            #self.base_time = self.clock_provider.get_property('clock').get_time()
            #client_clock = GstNet.NetClientClock.new('clock', self.host, self.clock_port, self.base_time)
            client_clock = self.system_clock
            self.base_time = client_clock.get_time()
        else:
            print("connecting to net clock %s:%s" % (self.master.host, self.clock_port))
            self.base_time = self.master.get_basetime()
            client_clock = GstNet.NetClientClock.new('clock', self.master.host, self.clock_port, self.base_time)
        
        time.sleep(2.0) # Wait for the clock to stabilise

        self.playbin.use_clock(client_clock)
        self.playbin.set_start_time(Gst.CLOCK_TIME_NONE)
        self.playbin.set_base_time(self.base_time)
        #self.playbin.set_latency (0.1);   
        
 
        # wait until things stop
        bus =  self.playbin.get_bus()
        bus.add_signal_watch()
        bus.connect("message", self.on_message) 

        print("setting uri to %s" % (self.track,))
        self.playbin.set_property('uri', self.track)
       
        print("setting basetime to %s" % (self.base_time,))
        self.playbin.set_state(Gst.State.PLAYING)
       

    def install_pyro_event_callback(self, daemon):
        """
        Add a callback to the tkinter event loop that is invoked every so often.
        The callback checks the Pyro sockets for activity and dispatches to the
        daemon's event process method if needed.
        """

        def pyro_event():
            while True:
                # for as long as the pyro socket triggers, dispatch events
                s, _, _ = select.select(daemon.sockets, [], [], 0.01)
                if s:
                    daemon.events(s)
                else:
                    # no more events, stop the loop, we'll get called again soon anyway
                    break
            GObject.timeout_add(20, pyro_event)

        GObject.timeout_add(20, pyro_event)



if __name__ == '__main__':

    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(('google.com', 0))
    default_host = s.getsockname()[0]

    parser = argparse.ArgumentParser(description='Syncronise music accross machines.')

    parser.add_argument('--playertype', type=str, dest='playertype', default='controller',
        help='player type. master or slave (default slave)')
    
    parser.add_argument('--port', type=int, dest='clock_port', default='5342',
        help='port used for the network clock')

    parser.add_argument('--host', type=str, default=default_host, help="Host ip you wish to bind to")

    parser.add_argument('--test-sync', dest='testsync', action='store_true', help="Play test file to check sync")
    parser.set_defaults(testsync=False)

    args = parser.parse_args()

    Gst.init(sys.argv)

    register_name = None

    try:

        if args.playertype == "master":

            if not args.host:   
                raise AttributeError("host parameter required")

            player = Player(args.host, args.clock_port)
 
            register_name = "partyzone.masterplayer (%s)" % gethostname()
            ns = Pyro4.naming.locateNS()

            try:
                existing = ns.lookup(register_name)
                print("Player still exists in Name Server with id: %s" % existing.object)
                print("Previous daemon socket port: %d" % existing.port)
                # start the daemon on the previous port
                daemon = Pyro4.core.Daemon(host=args.host, port=existing.port)
                # register the object in the daemon with the old objectId
                daemon.register(player, objectId=existing.object)
            except Pyro4.errors.NamingError:

                # just start a new daemon on a random port
                daemon = Pyro4.core.Daemon(args.host)
                # register the object in the daemon and let it get a new objectId
                # also need to register in name server because it's not there yet.
                uri = daemon.register(player)
                ns.register(register_name, uri)
                print("Server started.")

            # add a Pyro event callback to the gui's mainloop
            player.install_pyro_event_callback(daemon)
            GObject.MainLoop().run()

        elif args.playertype == "slave":

            if not args.host:
                raise AttributeError("host parameter required")

            ns = Pyro4.naming.locateNS()
            # Get master ip address
            master_uri = list(ns.list(prefix="partyzone.masterplayer").values())[0]
            master = Pyro4.Proxy(master_uri)
            register_name = "partyzone.slave (%s)" % gethostname()
            player = Player(args.host, args.clock_port, master)

            try:
                existing = ns.lookup(register_name)
                print("Player still exists in Name Server with id: %s" % existing.object)
                print("Previous daemon socket port: %d" % existing.port)
                # start the daemon on the previous port
                daemon = Pyro4.core.Daemon(host=args.host, port=existing.port)
                # register the object in the daemon with the old objectId
                daemon.register(player, objectId=existing.object)
            except Pyro4.errors.NamingError:
                # just start a new daemon on a random port
                daemon = Pyro4.core.Daemon(args.host)
                # register the object in the daemon and let it get a new objectId
                # also need to register in name server because it's not there yet.
                uri = daemon.register(player)
                ns.register(register_name, uri)
                print("Slave started.")

            # add a Pyro event callback to the gui's mainloop
            player.install_pyro_event_callback(daemon)
            GObject.MainLoop().run()


	elif args.testsync:

	    # Example controller
            with Pyro4.locateNS() as ns:
                players = ns.list(prefix="partyzone")
                master = None
                slaves = []
                for name, uri in players.items():
                    if "partyzone.masterplayer" in name:
                        master = Pyro4.Proxy(uri)
                    else:
                        slaves.append(Pyro4.Proxy(uri))
                print("master: " + str(master))
                print("slaves: " + str(slaves))

                if not master:
                    print("No master player found")
                    sys.exit(0)

            path = os.path.dirname(os.path.realpath(__file__))
	        #filepath = 'file://' + os.path.join(path, 'testing/test/mp3')
            filepath = 'file:///home/glenn/test.mp3'

            master.track = filepath
            master.play()

            if len(slaves) > 0:
                slaves[0].track = filepath
                slaves[0].play()

        else:  # Controller

            # Example controller
            with Pyro4.locateNS() as ns:
                players = ns.list(prefix="partyzone")
                player_objects = []
                for name, uri in players.items():
                    player_objects.append(Pyro4.Proxy(uri))

                if not player_objects:
                    print("No players found")
                    sys.exit(0)

            while True:
                print("call...")
                for p in player_objects:
                    try:
                        print(p.name)
                        print("Sleeping 1 second")
                        time.sleep(1)
                    except Pyro4.errors.ConnectionClosedError:     # or possibly even ProtocolError
                        print("Connection lost. REBINDING...")
                        print("(restart the server now)")
                        p._pyroReconnect()


    except KeyboardInterrupt:

        #with Pyro4.locateNS() as ns:
        #    players = ns.list(prefix="partyzone")
            
        #    for name, uri in players.items():
        #        player = Pyro4.Proxy(uri)
        #        player.cleanup()

        #if register_name:
        #    with Pyro4.locateNS() as ns:
        #        ns.remove(name=register_name)

        sys.exit()
