#!/usr/bin/env python

import sys
import gi
gi.require_version('Gst', '1.0')
gi.require_version('GstNet', '1.0')
import time
import signal
import select
import Pyro4
import argparse
import os
import os.path

from gi.repository import GObject, Gst, GstNet
from socket import gethostname

@Pyro4.expose
class Player(object):

    def __init__(self, port, is_master=False, master_ip_address="127.0.0.1", friendly_name=None):
        if friendly_name:
            self._name = friendly_name
        else:
            self._name = gethostname()
        self.port = int(port)
        self.is_master = is_master
        self._track_uri = None
        self.master_ip_address = master_ip_address
        #self.master_basetime = master_basetime
        
        if self.is_master:
            print("init master port %s" % self.port)
            self.system_clock = Gst.SystemClock.obtain()
            self.clock_provider = GstNet.NetTimeProvider.new(self.system_clock, self.master_ip_address, self.port)
            print("setting clock provider")
     
    @property
    def name(self):
        return self._name
 
    @property
    def track(self):
        if not self._track_uri:
            raise Exception("No track set")
        return self._track_uri

    @track.setter
    def track(self, value):
        self._track_uri = value

    def get_master_ip_address(self):
        return self.master_ip_address

    def on_message(self, bus, message):
        #print(str(message))
        t = message.type
        if t == Gst.MessageType.EOS:
            #self.player.set_state(Gst.State.NULL)
            pass
        elif t == Gst.MessageType.ERROR:
            #self.player.set_state(Gst.State.NULL)
            err, debug = message.parse_error()
            print("Error: %s" % err, debug)

    def play(self, master_basetime=None):
        if self.is_master:
            if not self.clock_provider:
                print("No clock_provider set ?")

            self.base_time = self.clock_provider.get_property('clock').get_time()
            print("setting clock provider")
        else:
            self.base_time = master_basetime

        print("setting basetime to %s" % (self.base_time,))

        print("connecting to net clock %s:%s" % (self.master_ip_address, self.port))
        client_clock = GstNet.NetClientClock.new('clock', self.master_ip_address, self.port, 0)
        
        time.sleep(1.0) # Wait for the clock to stabilise

        self.playbin = Gst.ElementFactory.make('playbin', 'playbin')

        self.playbin.use_clock(client_clock)
        self.playbin.set_base_time(self.base_time)
        self.playbin.set_latency (1.0);   
        self.playbin.set_start_time(Gst.CLOCK_TIME_NONE)

        # wait until things stop
        bus =  self.playbin.get_bus()
        bus.add_signal_watch()
        bus.connect("message", self.on_message) 

        print("setting uri to %s" % (self.track,))
        self.playbin.set_property('uri', self.track)
        self.playbin.set_state(Gst.State.PLAYING)
        

    def install_pyro_event_callback(self, daemon):
        """
        Add a callback to the tkinter event loop that is invoked every so often.
        The callback checks the Pyro sockets for activity and dispatches to the
        daemon's event process method if needed.
        """

        def pyro_event():
            while True:
                # for as long as the pyro socket triggers, dispatch events
                s, _, _ = select.select(daemon.sockets, [], [], 0.01)
                if s:
                    daemon.events(s)
                else:
                    # no more events, stop the loop, we'll get called again soon anyway
                    break
            GObject.timeout_add(20, pyro_event)

        GObject.timeout_add(20, pyro_event)

    def get_basetime(self):
        return self.base_time

    def state(self):
        return self.playbin.get_state()

    def stop(self):
        print("stop")
        self.playbin.set_state(Gst.State.NULL)


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Syncronise music accross machines.')

    parser.add_argument('--playertype', type=str, dest='playertype', default='controller',
        help='player type. master or slave (default slave)')
    
    parser.add_argument('--port', type=int, dest='clock_port', default='5342',
        help='port used for the network clock')

    parser.add_argument('--host', type=str, help="Host ip you wish to bind to")

    parser.add_argument('--name', type=str, dest='friendly_name', default='5342',
            help='friendly name for salve or master')

    args = parser.parse_args()

    Gst.init(sys.argv)

    register_name = None


#friendly_name

    try:

        if args.playertype == "master":

            if not args.host:   
                raise AttributeError("host parameter required")

            player = Player(args.clock_port, is_master=True, master_ip_address=args.host)
 
            register_name = "partyzone.masterplayer (%s)" % gethostname()
            ns = Pyro4.naming.locateNS()

            try:
                existing = ns.lookup(register_name)
                print("Player still exists in Name Server with id: %s" % existing.object)
                print("Previous daemon socket port: %d" % existing.port)
                # start the daemon on the previous port
                daemon = Pyro4.core.Daemon(host=args.host, port=existing.port)
                # register the object in the daemon with the old objectId
                daemon.register(player, objectId=existing.object)
            except Pyro4.errors.NamingError:

                # just start a new daemon on a random port
                daemon = Pyro4.core.Daemon(args.host)
                # register the object in the daemon and let it get a new objectId
                # also need to register in name server because it's not there yet.
                uri = daemon.register(player)
                ns.register(register_name, uri)
                print("Server started.")

            # add a Pyro event callback to the gui's mainloop
            player.install_pyro_event_callback(daemon)
            GObject.MainLoop().run()

        elif args.playertype == "slave":

            if not args.host:
                raise AttributeError("host parameter required")

            ns = Pyro4.naming.locateNS()
            # Get master ip address
            master_uri = list(ns.list(prefix="partyzone.masterplayer").values())[0]
            master = Pyro4.Proxy(master_uri)
            register_name = "partyzone.slave (%s)" % gethostname()
            master_ip = master.get_master_ip_address()           
            print ("master ip : %s" % (master_ip,))

            player = Player(args.clock_port, master_ip_address=master_ip, is_master=False)

            try:
                existing = ns.lookup(register_name)
                print("Player still exists in Name Server with id: %s" % existing.object)
                print("Previous daemon socket port: %d" % existing.port)
                # start the daemon on the previous port
                daemon = Pyro4.core.Daemon(host=args.host, port=existing.port)
                # register the object in the daemon with the old objectId
                daemon.register(player, objectId=existing.object)
            except Pyro4.errors.NamingError:
                # just start a new daemon on a random port
                daemon = Pyro4.core.Daemon(args.host)
                # register the object in the daemon and let it get a new objectId
                # also need to register in name server because it's not there yet.
                uri = daemon.register(player)
                ns.register(register_name, uri)
                print("Slave started.")

            # add a Pyro event callback to the gui's mainloop
            player.install_pyro_event_callback(daemon)
            GObject.MainLoop().run()


        else:  # Controller

            # Example controller
            with Pyro4.locateNS() as ns:
                players = ns.list(prefix="partyzone")
                master = None
                slaves = []
                for name, uri in players.items():
                    if "partyzone.masterplayer" in name:
                        master = Pyro4.Proxy(uri)
                    else:
                        slaves.append(Pyro4.Proxy(uri))
                print("master: " + str(master))
                print("slaves: " + str(slaves))

                if not master:
                    print("No master player found")
                    sys.exit(0)

            # We create a proxy with a PYRONAME uri.
            # That allows Pyro to look up the object again in the NS when
            # it needs to reconnect later.
            obj=master
            slave=slaves[0]

            print(master.get_basetime())
            uri = 'file:///home/test2.mp3'

            slaves[0].track = uri
            slaves[0].play(master_basetime=master.get_basetime())

            slaves[1].track = uri
            slaves[1].play(master_basetime=master.get_basetime())

            while True:
                print("call...")
                try:
                    print(obj.name)
                    print(slave.name)
                    print("Sleeping 1 second")
                    time.sleep(1)
                except Pyro4.errors.ConnectionClosedError:     # or possibly even ProtocolError
                    print("Connection lost. REBINDING...")
                    print("(restart the server now)")
                    obj._pyroReconnect()
                    slave._pyroReconnect()


    except KeyboardInterrupt:

        #if register_name:
        #    with Pyro4.locateNS() as ns:
        #        ns.remove(name=register_name)

        sys.exit()
    

    
