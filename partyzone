#!/usr/bin/env python

from __future__ import print_function

import sys
import gi
gi.require_version('Gst', '1.0')
gi.require_version('GstNet', '1.0')
import time
import signal
import select
import argparse
import os

os.environ["PYRO_LOGFILE"] = "pyro.log"
os.environ["PYRO_LOGLEVEL"] = "DEBUG"

import os.path
import socket
import Pyro4

from gi.repository import GObject, Gst, GstNet
from socket import gethostname


@Pyro4.expose
class Player(object):

    def __init__(self, host, clock_port, master=None, name=None, card=None):
        if name:
            self._name = name
        else:
            self._name = gethostname()
        self._host = host
        self.clock_port = int(clock_port)
        self.master = master
        self.is_master = False if master else True
        self._track_uri = None
        self._card = card
        self._callback = None
        self.playbin = Gst.ElementFactory.make('playbin', 'playbin')

        if self.is_master:
            print("master player started on host: %s" % (self.host,))
        else:
            print("slave player started on host: %s" % (self.host,))
            print(self.master.name)

        self.base_time = Gst.CLOCK_TIME_NONE
        self.stop()

        if self._card:
            print("setting card to " + self._card)
            alsa_sink = Gst.ElementFactory.make("alsasink", "alsasink")
            alsa_sink.set_property('device', self._card)
            self.playbin.set_property("audio-sink", alsa_sink)

        if self.is_master:
            self.system_clock = Gst.SystemClock.obtain()
            time.sleep(1) # Wait for the clock to stabilise
            self.clock_provider = GstNet.NetTimeProvider.new(self.system_clock, self.host, self.clock_port)
            if not self.clock_provider:
                print("No clock_provider set ?")
        else:
            # Check that master is playing or not
            if self.master.state() == Gst.State.PLAYING:
                self.track = self.master.track
                self.play()

    @property
    def name(self):
        return self._name

    @property
    def host(self):
        return self._host
 
    @property
    def track(self):
        if not self._track_uri:
            raise Exception("No track set")
        return self._track_uri

    @track.setter
    def track(self, value):
        print("setting track to %s" % (value,))
        self._track_uri = value

    def on_message(self, bus, message):
        t = message.type
        if t == Gst.MessageType.EOS:
            self.playbin.set_state(Gst.State.NULL)
            if self.is_master and self._callback:
                self._callback.play_done(self.name)    # invoke the callback object

        elif t == Gst.MessageType.BUFFERING:
            percent = message.parse_buffering()
            print('\r ' + str(percent) + '% buffered', end='')
            if int(percent) == 100:
                print('\n')
            sys.stdout.flush()
        #elif t == Gst.MessageType.STATE_CHANGED:
        #    print("State Changed")
        elif t == Gst.MessageType.ERROR:
            self.playbin.set_state(Gst.State.NULL)
            err, debug = message.parse_error()
            print("Error: %s" % err, debug)

    def set_volume(self, vol):
        self.playbin.set_property('volume', vol)

    def set_callback_uri(self, callback_uri):
        self._callback_uri = callback_uri
        print("setting callback %s" % (self._callback_uri,))
        self._callback = Pyro4.Proxy(self._callback_uri)

    def get_basetime(self):
        return self.base_time

    def state(self):
        state = int(self.playbin.get_state(Gst.CLOCK_TIME_NONE)[1])
        print(state)
        return state

    def stop(self):
        self.playbin.set_state(Gst.State.NULL)
        if self.is_master and self._callback:
            self._callback.play_done(self.name)    # invoke the callback object

    @Pyro4.oneway
    def test(self):
        print("oneway test call")

    @Pyro4.oneway
    def play(self):

        if self.is_master:
            #print("connecting to net clock %s:%s" % (self.host, self.clock_port))
            #self.base_time = self.clock_provider.get_property('clock').get_time()
            #client_clock = GstNet.NetClientClock.new('clock', self.host, self.clock_port, self.base_time)
            client_clock = self.system_clock
            self.base_time = client_clock.get_time()
        else:
            print("connecting to net clock %s:%s" % (self.master.host, self.clock_port))
            self.base_time = self.master.get_basetime()
            client_clock = GstNet.NetClientClock.new('clock', self.master.host, self.clock_port, self.base_time)
        
        time.sleep(1.0) # Wait for the clock to stabilise

        self.playbin.use_clock(client_clock)
        self.playbin.set_start_time(Gst.CLOCK_TIME_NONE)
        self.playbin.set_base_time(self.base_time)    
 
        # wait until things stop
        bus =  self.playbin.get_bus()
        bus.add_signal_watch()
        bus.connect("message", self.on_message) 

        print("setting uri to %s" % (self.track,))
        self.playbin.set_property('uri', self.track)
       
        print("setting basetime to %s" % (self.base_time,))
        self.playbin.set_state(Gst.State.PLAYING)

        if self.is_master and self._callback:
            print("play started callback %s" % (self._callback_uri,))
            Pyro4.Proxy(self._callback_uri).play_started()    # invoke the callback object

    def install_pyro_event_callback(self, daemon):
        """
        Add a callback to the tkinter event loop that is invoked every so often.
        The callback checks the Pyro sockets for activity and dispatches to the
        daemon's event process method if needed.
        """

        def pyro_event():
            while True:
                # for as long as the pyro socket triggers, dispatch events
                s, _, _ = select.select(daemon.sockets, [], [], 0.01)
                if s:
                    daemon.events(s)
                else:
                    # no more events, stop the loop, we'll get called again soon anyway
                    break
            GObject.timeout_add(20, pyro_event)

        GObject.timeout_add(20, pyro_event)


if __name__ == '__main__':

    # default host name
    default_host = '127.0.0.1'
    default_friendly_name = None

    parser = argparse.ArgumentParser(description='Syncronise music accross machines.')

    parser.add_argument('--playertype', type=str, dest='playertype', default='controller',
        help='player type. master or slave (default slave)')
    
    parser.add_argument('--clock-port', type=int, dest='clock_port', default='5342',
        help='port used for the network clock')

    parser.add_argument('--host', type=str, default=default_host, help="Host ip you wish to bind to")

    parser.add_argument('--pyro-port', dest='pyro_port', type=int, default=6564, help="Pyro port you wish to bind to")

    parser.add_argument('--card', type=str, default=None, help="Alsa card to use")

    parser.add_argument('--name', type=str, default=default_friendly_name, help="Friendly name for the player")

    parser.add_argument('--play', type=str, default=None, help="Play file for testing")

    parser.add_argument('--test-sync', dest='testsync', action='store_true', help="Play test file to check sync")
    parser.set_defaults(testsync=False)

    # parser.add_argument('-r', '--recursive-play', dest='recursive', action=readable_dir, default=None, help="Directory of items to recursively play")

    args = parser.parse_args()
   
    if not args.play: 
        while True:  # Debian at least fails dns at startup with systemd. Even specifying after network
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                s.connect(('google.com', 0))
                default_host = s.getsockname()[0]
                default_friendly_name = gethostname()
                break
            except:
                time.sleep(5)
            
    print("host: " + str(args.host))

    Gst.init(sys.argv)

    register_name = None

    try:

        if args.playertype == "master":

            if not args.host:   
                raise AttributeError("host parameter required")

            player = Player(args.host, args.clock_port, name=args.name, card=args.card)
 
            register_name = "partyzone.masterplayer (%s)" % args.name
            ns = Pyro4.naming.locateNS()

            try:
                existing = ns.lookup(register_name)
                print("Player still exists in Name Server with id: %s" % existing.object)
                print("Previous daemon socket port: %d" % existing.port)
                # start the daemon on the previous port
                daemon = Pyro4.core.Daemon(host=args.host, port=existing.port)
                # register the object in the daemon with the old objectId
                daemon.register(player, objectId=existing.object)
            except Pyro4.errors.NamingError:

                # just start a new daemon on a random port
                daemon = Pyro4.core.Daemon(args.host)
                # register the object in the daemon and let it get a new objectId
                # also need to register in name server because it's not there yet.
                uri = daemon.register(player)
                ns.register(register_name, uri)
                print("Server started.")

            # add a Pyro event callback to the gui's mainloop
            player.install_pyro_event_callback(daemon)
            GObject.MainLoop().run()

        elif args.playertype == "slave":

            if not args.host:
                raise AttributeError("host parameter required")

            ns = None

            while True:
                try:
                    ns = Pyro4.naming.locateNS()
                    break
                except Pyro4.errors.NamingError:
                    print("Can't find Pyro nameserver!")
                except ex:
                    print(str(ex))
                    sys.exit(1)
                time.sleep(5)

            master_uri = None

            while True:
                try:
                    master_uri = list(ns.list(prefix="partyzone.masterplayer").values())[0]
                    break
                except IndexError:           
                    print("Can't find master player")
                except ex:
                    print(str(ex))
                    sys.exit(1)
                time.sleep(5)          

            master = Pyro4.Proxy(master_uri)
            register_name = "partyzone.slave (%s)" % args.name
            player = Player(args.host, args.clock_port, master, name=args.name, card=args.card)

            try:
                existing = ns.lookup(register_name)
                print("Player still exists in Name Server with id: %s" % existing.object)
                print("Previous daemon socket port: %d" % existing.port)
                # start the daemon on the previous port
                daemon = Pyro4.core.Daemon(host=args.host, port=existing.port)
                # register the object in the daemon with the old objectId
                daemon.register(player, objectId=existing.object)
            except Pyro4.errors.NamingError:
                # just start a new daemon on a random port
                daemon = Pyro4.core.Daemon(host=args.host, port=args.pyro_port)
                # register the object in the daemon and let it get a new objectId
                # also need to register in name server because it's not there yet.
                uri = daemon.register(player)
                ns.register(register_name, uri)
                print("Slave started.")

            # add a Pyro event callback to the gui's mainloop
            player.install_pyro_event_callback(daemon)
            GObject.MainLoop().run()

        # elif args.recursive:

        #     # Recursive directory player
        #     with Pyro4.locateNS() as ns:
        #         players = ns.list(prefix="partyzone")
        #         master = None
        #         slaves = []
        #         for name, uri in players.items():
        #             if "partyzone.masterplayer" in name:
        #                 master = Pyro4.Proxy(uri)
        #             else:
        #                 slaves.append(Pyro4.Proxy(uri))

        #         print("master: " + str(master))
        #         print("slaves: " + str(slaves))

        #         if not master:
        #             print("No master player found")
        #             sys.exit(0)

        #     print("Playing dir: " + args.recursive)
            
        #     controller = Controller(master, slaves, args.recursive)
            
        #     with Pyro4.core.Daemon() as daemon:
        #         daemon.register(controller)
            
        #         # add a Pyro event callback to the gui's mainloop
        #         #controller.install_pyro_event_callback(daemon)
        #         #GObject.MainLoop().run()
        #         daemon.requestLoop()

        elif args.testsync:

            # Example controller
            with Pyro4.locateNS() as ns:
                players = ns.list(prefix="partyzone")
                master = None
                slaves = []
                for name, uri in players.items():
                    if "partyzone.masterplayer" in name:
                        master = Pyro4.Proxy(uri)
                    else:
                        slaves.append(Pyro4.Proxy(uri))
                print("master: " + str(master))
                print("slaves: " + str(slaves))

                if not master:
                    print("No master player found")
                    sys.exit(0)

            path = os.path.dirname(os.path.realpath(__file__))
            #filepath = 'file://' + os.path.join(path, 'testing/test/mp3')
            filepath = 'file:///home/glenn/test.mp3'

            master.track = filepath
            master.play()

            if len(slaves) > 0:
                try:
                    slaves[0].track = filepath
                    slaves[0].play()
                except Pyro4.errors.CommunicationError as ex:
                    pass

        elif args.play:

            player = Player(args.host, args.clock_port, name=args.name, card=args.card)

            filepath = 'file://' + args.play

            print("playing " + filepath)
            player.track = filepath
            player.play()

            GObject.MainLoop().run()

        else:  # Controller

            # Example controller
            with Pyro4.locateNS() as ns:
                players = ns.list(prefix="partyzone")
                player_objects = []
                for name, uri in players.items():
                    player_objects.append(Pyro4.Proxy(uri))

                if not player_objects:
                    print("No players found")
                    sys.exit(0)

            while True:
                print("call...")
                for p in player_objects:
                    try:
                        print(p.name)
                        p.test()
                        print("Sleeping 1 second")
                        time.sleep(1)
                    except Pyro4.errors.ConnectionClosedError:     # or possibly even ProtocolError
                        print("Connection lost. REBINDING...")
                        print("(restart the server now)")
                        p._pyroReconnect()


    except KeyboardInterrupt:

        #with Pyro4.locateNS() as ns:
        #    players = ns.list(prefix="partyzone")
            
        #    for name, uri in players.items():
        #        player = Pyro4.Proxy(uri)
        #        player.cleanup()

        #if register_name:
        #    with Pyro4.locateNS() as ns:
        #        ns.remove(name=register_name)

        sys.exit()
